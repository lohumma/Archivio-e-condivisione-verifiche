<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Quiz | 10 MANCA NICCOLO SILVIO</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: auto; padding: 20px; }
    .hidden { display: none !important; }
    .question { font-weight: bold; margin-top: 20px; }
    .option { display: block; margin: 6px 0; }
    .indicators button { width: 30px; margin: 2px; }
    .green { background: palegreen; }
    .red { background: lightcoral; }
    .noselect, .noselect *:not(input):not(textarea):not(select) { user-select: none; }
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: flex; align-items: center; justify-content: center; z-index: 999; }
    .modal { background: #fff; padding: 20px; border-radius: 8px; max-width: 480px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.2); text-align: center; }
    .modal button { margin: 8px; padding: 10px 16px; }
    .btn-success { background: palegreen; }
    .status { margin-top: 10px; font-weight: bold; }
  </style>
</head>
<body class="noselect">
  <h2 id="pageTitle">Compito di Tecnologie dei processi di produzione</h2>
  <div id="intro">
    <p><strong>Studente:</strong> 10 MANCA NICCOLO SILVIO</p>
    <p><strong>Classe:</strong> 4 AGC</p>
    <p><label><input type="checkbox" id="riduzioneTempo"  disabled> Riduzione o tempo aggiuntivo</label></p>
    <div style="margin:12px 0; padding:12px; border:1px solid #cbd5e1; border-radius:6px; background:#f1f5f9; color:#0f172a;">
      <strong>Regole del test:</strong>
      <ul style="margin:8px 0 0 18px; padding:0;">
        <li>Una volta avviato il test, entrerai in modalit? fullscreen, non uscire MAI dalla modalit? fullscreen o riceverai un ammonimento. Al secondo ammonimento il test si concluder? automaticamente e dovrai consegnere il documento.</li>
        <li>Se aprirai un'altra scheda, aggiorni la pagina o riduci a icona il test, riceverai un ammonimento; al secondo ammonimento il test si concluder? automaticamente e dovrai consegnere il documento.</li>
        <li>Una volta concluso il test, dovrai salvare una cartella con due file: PDF e JSON. Cerca la cartella appena creata e caricala sul cloud del docente.</li>
        <li>Non serve scaricare il file "Template" a fine test, poich? risulter? vuoto.</li>
        <li>Quando hai finito il test, avverti il docente alzando la mano.</li>
      </ul>
    </div>
    <button onclick="startQuiz()">Inizia quiz</button>
  </div>

  <div id="quiz" class="hidden">
    <div class="question" id="questionText"></div>
    <div id="options"></div>
    <div style="height:12px;"></div>
    <div style="display:flex; gap:10px; margin:12px 0;">
      <button onclick="prev()">&lt;&lt; Precedente</button>
      <button onclick="next()">Successiva &gt;&gt;</button>
    </div>
    <div style="height:12px;"></div>
    <div class="indicators" id="indicators" style="margin-bottom:14px;"></div>
    <div style="display:flex; justify-content:center; gap:12px; margin:16px 0;">
      <button onclick="finishQuiz()" style="padding:12px 18px; font-size:16px;">Completa e chiudi il test</button>
    </div>
  </div>
  <div id="downloadOverlay" class="hidden overlay">
    <div class="modal">
      <p>Salva una cartella con PDF e JSON e consegnala al docente.</p>
      <div>
        <button id="downloadZipBtn" onclick="saveResultsFolder()">Salva cartella risultati</button>
      </div>
      <div id="downloadStatus" class="status"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const allQuestions = [{"qid":"q1","qhash":"17d87mf","question":"Le camere Mirrorless si distinguono dalle reflex tradizionali per:","options":[{"id":"o11","hash":"1ycdc4k","t":"La presenza dello specchio"},{"id":"o12","hash":"5838d","t":"L’assenza dello specchio e del mirino ottico tradizionale"},{"id":"o13","hash":"1ywcjii","t":"L’utilizzo esclusivo della pellicola fotografica"},{"id":"o14","hash":"1xiej1n","t":"Un corpo macchina più grande e pesante"}],"correctHash":"e0jz3n"},{"qid":"q2","qhash":"17n7tbe","question":"Quante modalità di scatto esistono?","options":[{"id":"o21","hash":"1twa8j3","t":"3"},{"id":"o22","hash":"1u69u82","t":"6"},{"id":"o23","hash":"1ug9fx1","t":"5"},{"id":"o24","hash":"1sic828","t":"10"}],"correctHash":"1ai7oqh"},{"qid":"q3","qhash":"17x7f0d","question":"Lo scatto continuo è ideale per:","options":[{"id":"o31","hash":"1v0bssy","t":"fotografie statiche"},{"id":"o32","hash":"1uqc73z","t":"fotografie in cui il fotografo si deve inserire nell’inquadratura"},{"id":"o33","hash":"1ugclf0","t":"per soggetti in movimento o per cogliere  espressioni nei volti"},{"id":"o34","hash":"1u6czq1","t":"Tutte le precedenti"}],"correctHash":"1wg4hrh"},{"qid":"q4","qhash":"15za75k","question":"Le immagini scattate con una reflex digitale possono essere salvate in formato:","options":[{"id":"o41","hash":"zxaum5","t":"RAW"},{"id":"o42","hash":"z3c1j8","t":"JPEG"},{"id":"o43","hash":"zdbn87","t":"TIFF"},{"id":"o44","hash":"yjcu5a","t":"Tutte le precedenti"}],"correctHash":"uycqcy"},{"qid":"q5","qhash":"1699suj","question":"Il flash elettronico","options":[{"id":"o51","hash":"s5p4ow","t":"È usato sia in interni che in esterni, anche come luce di riempimento per attenuare contrasti eccessivi"},{"id":"o52","hash":"sznxrt","t":"Elimina le ombre e garantisce una luce uniforme sul soggetto"},{"id":"o53","hash":"spoc2u","t":"È pensato per macro e riprese ravvicinate"},{"id":"o54","hash":"tjn55r","t":"E’  pensato solo per riprese a lunga esposizione notturna"}],"correctHash":"1s6thnv"},{"qid":"q6","qhash":"16j9eji","question":"Per impostare l’autofocus singolo, nell’Area autofocus devo selezionare","options":[{"id":"o61","hash":"1w3s8h7","t":"Priorità AF-S"},{"id":"o62","hash":"1wdru66","t":"Priorità AF-C"},{"id":"o63","hash":"1wnrfv5","t":"Selezione area AF"},{"id":"o64","hash":"1wxr1k4","t":"Sia la A che la C"}],"correctHash":"emnqde"},{"qid":"q7","qhash":"16t908h","question":"Per bilanciare il bianco in una reflex digitale","options":[{"id":"o71","hash":"xpavke","t":"Bisogna sempre scattare solo in bianco e nero"},{"id":"o72","hash":"xfb9vf","t":"Si ottiene modificando la lunghezza focale dell’obiettivo"},{"id":"o73","hash":"x5bo6g","t":"E’ necessario applicare dei filtri davanti all’obiettivo"},{"id":"o74","hash":"z38w19","t":"E’ sufficiente impostare il valore più opportuno dal menù"}],"correctHash":"1kaf3m0"},{"qid":"q8","qhash":"14vbsdo","question":"In merito alla dimensione della foto è conveniente impiegare:","options":[{"id":"o81","hash":"1srqp5l","t":"il massimo numero di Pixel che la DSLR permette"},{"id":"o82","hash":"1rxrw2o","t":"il minimo numero di  Pixel che la DSLR permette"},{"id":"o83","hash":"1s7rhrn","t":"Sempre la stessa dimensione indipendentemente dall’uso"},{"id":"o84","hash":"1tlpi8i","t":"Una dimensione scelta a caso senza considerare la stampa o l’uso digitale"}],"correctHash":"1xqj6jd"},{"qid":"q9","qhash":"155be2n","question":"Se voglio riprodurre a monitor le immagini salvate nella scheda quale menu utilizzo?","options":[{"id":"o91","hash":"1tvs9fg","t":"Menu play"},{"id":"o92","hash":"1upr2id","t":"Menu ripresa"},{"id":"o93","hash":"1ufrgte","t":"Menu impostazioni"},{"id":"o94","hash":"1t1tgcj","t":"Menu impostazioni personalizzate"}],"correctHash":"113efuh"},{"qid":"q10","qhash":"1dtc5wl","question":"Come può avvenire la regolazione della sensibilità?","options":[{"id":"o101","hash":"1dlpshe","t":"Menù ripresa – bilanciamento del bianco – scegliere il valore – ok"},{"id":"o102","hash":"1dbq6sf","t":"Menù ripresa – sensibilità iso – scegliere il valore – ok"},{"id":"o103","hash":"1d1ql3g","t":"Menù ripresa – dimensione foto – scegliere il valore  - ok"},{"id":"o104","hash":"1crqzeh","t":"Nessuna delle precedenti"}],"correctHash":"1y0k3lg"},{"qid":"q11","qhash":"1djck7m","question":"Durante lo scatto fotografico, il sollevamento dello specchio:","options":[{"id":"o111","hash":"1cho87j","t":"Impedisce alla luce di entrare nell’obiettivo"},{"id":"o112","hash":"1crntwi","t":"Migliora la visione nel mirino"},{"id":"o113","hash":"1d1nflh","t":"Mantiene l’immagine visibile durante lo scatto"},{"id":"o114","hash":"1b3q7qo","t":"Consente alla luce di raggiungere il sensore o la pellicola"}],"correctHash":"cr760i"},{"qid":"q12","qhash":"1d9cyin","question":"Nelle Reflex tradizionali lo specchio:","options":[{"id":"o121","hash":"hf8emc","t":"Convoglia la luce direttamente sul sensore in modo continuo"},{"id":"o122","hash":"i977p9","t":"Riflette la luce che entra attraverso l’obiettivo"},{"id":"o123","hash":"hz7m0a","t":"Ha solo una funzione estetica e decorativa"},{"id":"o124","hash":"gl9ljf","t":"Non è presente nelle Reflex tradizionali."}],"correctHash":"pg07g4"},{"qid":"q13","qhash":"1czdcto","question":"Quale tipo di misurazione tiene conto principalmente del soggetto centrale attribuendo importanza decrescente ai soggetti marginali?","options":[{"id":"o131","hash":"gb6uch","t":"Spot"},{"id":"o132","hash":"fh819k","t":"Semispot"},{"id":"o133","hash":"fr7myj","t":"Media ponderata"},{"id":"o134","hash":"h55nfe","t":"Sia Spot che Semispot"}],"correctHash":"zei46z"}];
    const safeName = (str) => String(str || "").trim().replace(/\s+/g, "_").replace(/[^A-Za-z0-9_-]/g, "");
    const hashToken = (str) => String(str || "").trim().replace(/\s+/g, "_").replace(/[^A-Za-z0-9_-]/g, "");
    const hashId = (value) => {
      const str = String(value || "");
      let hash = 2166136261;
      for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, 16777619);
      }
      return (hash >>> 0).toString(36);
    };
    const hashJoin = (qid, oid) => hashId(qid + "+" + oid);
    const studentLabel = "10  MANCA NICCOLO SILVIO";
    const studentReg = "15";
    const studentSurname = "MANCA";
    const studentName = "GUIDO";
    const materiaLabel = "Tecnologie dei processi di produzione";
    const classeLabel = "4 AGC";
    const topicLabel = "Fotocamera e illuminazione";
    const generatedDate = new Date().toLocaleDateString("it-IT");
    let current = 0;
    const answers = {};
    const questionText = document.getElementById('questionText');
    const optionsEl = document.getElementById('options');
    const indicators = document.getElementById('indicators');
    const quizEl = document.getElementById('quiz');
    const introEl = document.getElementById('intro');
    const overlay = document.getElementById('downloadOverlay');
    const downloadStatus = document.getElementById('downloadStatus');

    let finishAsked = false;
    let downloadedFiles = false;

    function requestFull() {
      const el = document.documentElement;
      const fn = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
      if (fn) {
        fn.call(el).catch(() => {});
      }
    }

    function renderQuestion() {
      const q = allQuestions[current];
      questionText.textContent = (current + 1) + '. ' + q.question;
      optionsEl.innerHTML = '';
      if (q.open) {
        const ta = document.createElement('textarea');
        ta.rows = 4;
        ta.style.width = '100%';
        ta.value = answers[q.qid] || '';
        ta.addEventListener('input', () => answers[q.qid] = ta.value);
        optionsEl.appendChild(ta);
      } else {
        const letter = (i) => String.fromCharCode(65 + i);
        q.options.forEach((opt, idx) => {
          const lbl = document.createElement('label');
          lbl.className = 'option';
          const inp = document.createElement('input');
          inp.type = 'radio';
          inp.name = 'opt';
          inp.value = opt.id;
          inp.checked = answers[q.qid] === opt.id;
          inp.addEventListener('change', () => answers[q.qid] = opt.id);
          lbl.appendChild(inp);
          lbl.append(' ' + letter(idx) + '. ' + opt.t);
          optionsEl.appendChild(lbl);
        });
      }
      renderIndicators();
    }

    function renderIndicators() {
      indicators.innerHTML = '';
      allQuestions.forEach((q, idx) => {
        const b = document.createElement('button');
        b.textContent = idx + 1;
        b.className = answers[q.qid] ? 'green' : '';
        b.onclick = () => { current = idx; renderQuestion(); };
        indicators.appendChild(b);
      });
    }

    function startQuiz() {
      introEl.classList.add('hidden');
      quizEl.classList.remove('hidden');
      requestFull();
      renderQuestion();
    }
    function next() { if (current < allQuestions.length - 1) { current++; renderQuestion(); } }
    function prev() { if (current > 0) { current--; renderQuestion(); } }

    function finishQuiz() {
      finishAsked = true;
      quizEl.classList.add('hidden');
      overlay.classList.remove('hidden');
    }

    function buildPdfBlob() {
      const jsPdfFactory = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF || null;
      if (!jsPdfFactory) {
        alert("Libreria jsPDF non caricata. Impossibile generare il PDF.");
        return null;
      }
      const doc = new jsPdfFactory();
      const margin = 20; // 2 cm
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const maxWidth = pageWidth - margin * 2;
      const bottomLimit = () => pageHeight - margin;
      const lineH = 6;
      const letter = (i) => String.fromCharCode(65 + i);
      const colors = {
        primary: [18, 91, 190],
        section: [205, 221, 248],
        text: [15, 30, 60],
        muted: [90, 110, 140]
      };
      let y = margin;
      const ensurePage = (extra = 0) => {
        if (y + extra > bottomLimit()) {
          doc.addPage();
          y = margin;
        }
      };
      const writeLines = (text, opts = {}) => {
        const { indent = 0, font = "normal", size = 11, color = [0,0,0] } = opts;
        doc.setFont("helvetica", font);
        doc.setFontSize(size);
        doc.setTextColor(...color);
        const lines = doc.splitTextToSize(text, maxWidth - indent);
        lines.forEach(txt => {
          ensurePage(lineH);
          doc.text(txt, margin + indent, y);
          y += lineH;
        });
      };
      // Header sezione dati
      doc.setFillColor(...colors.section);
      doc.rect(margin, y, maxWidth, 36, "F");
      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.text("Test su " + topicLabel, margin + 2, y + 8);
      doc.setFontSize(11);
      doc.text("Studente: " + studentLabel, margin + 2, y + 15);
      doc.text("Materia: " + materiaLabel, margin + 2, y + 21);
      doc.text("Classe: " + classeLabel, margin + 2, y + 27);
      doc.text("Data: " + generatedDate, margin + 2, y + 33);
      y += 44;

      doc.setFontSize(11);
      allQuestions.forEach((q, idx) => {
        const questionText = (idx + 1) + ". " + q.question;
        const optionsLines = q.open ? [] : (q.options || []).map((opt, i) => {
          const text = (typeof opt === "string") ? opt : (opt.t || opt.text || opt.testo || opt.label || "");
          return letter(i) + ". " + text;
        });
        const userIdx = answers[q.qid];
        const userLetter = q.open ? "" : (userIdx != null ? letter((q.options || []).findIndex(o => o.id === userIdx)) : "-");
        const correctIdx = q.open ? null : (q.options || []).findIndex(o => hashJoin(q.qid, o.id) === q.correctHash);
        const correctLetter = q.open ? "" : (Number.isInteger(correctIdx) ? letter(correctIdx) : "-");
        const correctOpt = (!q.open && Number.isInteger(correctIdx)) ? (q.options || [])[correctIdx] : null;
        const correctText = correctOpt ? (correctOpt.t || correctOpt.text || correctOpt.testo || correctOpt.label || "") : "";
        const correctLine = q.open ? "" : (correctText ? (correctLetter + ". " + correctText) : correctLetter);

        let blockHeight = doc.splitTextToSize(questionText, maxWidth).length * lineH;
        blockHeight += optionsLines.length * lineH;
        if (!q.open) blockHeight += lineH * 2; // hai risposto + corretta
        if (q.open) blockHeight += doc.splitTextToSize("Risposta: " + (answers[q.qid] || ""), maxWidth).length * lineH;
        blockHeight += lineH * 2;
        ensurePage(blockHeight);

        writeLines(questionText, { font: "bold" });
        if (q.open) {
          const ans = answers[q.qid] || '';
          writeLines("Risposta: " + ans, { indent: 2 });
          writeLines("Domanda aperta - da correggere manualmente.", { indent: 2, color: [90,90,90] });
        } else {
          optionsLines.forEach(line => writeLines(line, { indent: 2 }));
          writeLines("Hai risposto: " + userLetter, { indent: 2 });
          const isCorrect = userIdx != null && Number.isInteger(correctIdx) && (q.options || [])[correctIdx]?.id === userIdx;
          writeLines("Risposta corretta: " + correctLine, { indent: 2, color: isCorrect ? [0,128,0] : [200,0,0] });
        }
        ensurePage(8);
        doc.setDrawColor(...colors.section);
        doc.line(margin, y, margin + maxWidth, y);
        y += 6;
      });

      const closedQuestions = allQuestions.filter(q => !q.open);
      const totalClosed = closedQuestions.length;
      const correctClosed = closedQuestions.reduce((acc, q) => {
        const correctIdx = (q.options || []).findIndex(o => hashJoin(q.qid, o.id) === q.correctHash);
        return acc + ((answers[q.qid] != null && Number.isInteger(correctIdx) && (q.options || [])[correctIdx]?.id === answers[q.qid]) ? 1 : 0);
      }, 0);
      ensurePage(14);
      doc.setFillColor(...colors.section);
      doc.rect(margin, y, maxWidth, 16, "F");
      doc.setFont("helvetica", "bold");
      doc.setFontSize(11);
      doc.text("Totale risposte corrette: " + correctClosed + "/" + totalClosed, margin + 2, y + 7);
      if (totalClosed > 0) {
        const voto = (correctClosed / totalClosed * 10).toFixed(1);
        doc.text("Voto: " + voto, margin + 2, y + 13);
      }

      return doc.output("blob");
    }

    function buildJsonBlob() {
      const letter = (i) => String.fromCharCode(65 + i);
      const payloadDomande = allQuestions.map((q, idx) => {
        if (q.open) {
          return {
            tipo: "aperta",
            domanda: q.question,
            risposta: answers[q.qid] || ""
          };
        }
        const opts = (q.options || []).map((o, i) => ({
          id: o.id,
          testo: o.t,
          lettera: letter(i)
        }));
        const correctHash = q.correctHash;
        const userId = answers[q.qid];
        const correctOpt = opts.find(o => hashJoin(q.qid, o.id) === correctHash);
        const userOpt = opts.find(o => o.id === userId);
        return {
          tipo: "chiusa",
          domanda: q.question,
          opzioni: opts,
          risposta_corretta: correctOpt ? (correctOpt.lettera + ". " + correctOpt.testo) : "",
          risposta_data: userOpt ? (userOpt.lettera + ". " + userOpt.testo) : ""
        };
      });
      const out = {
        studente: studentLabel,
        classe: classeLabel,
        materia: materiaLabel,
        argomento: topicLabel,
        data: generatedDate,
        domande: payloadDomande
      };
      return new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
    }

    function buildBaseName() {
      const parts = ["quiz", studentReg, studentSurname, studentName, topicLabel]
        .map(safeName)
        .filter(Boolean);
      return parts.join("_");
    }

    async function writeFileToDir(dirHandle, fileName, blob) {
      const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob);
      await writable.close();
    }

    function triggerDownload(blob, name) {
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = name;
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function downloadFilesFallback(baseName, pdfBlob, jsonBlob) {
      triggerDownload(pdfBlob, baseName + ".pdf");
      triggerDownload(jsonBlob, baseName + ".json");
      downloadStatus.textContent = "File salvati nei download.";
      downloadedFiles = true;
      if (downloadedFiles) setTimeout(() => window.close(), 300);
    }

    async function saveResultsFolder() {
      const pdfBlob = buildPdfBlob();
      if (!pdfBlob) return;
      const jsonBlob = buildJsonBlob();
      const baseName = buildBaseName();
      if ("showDirectoryPicker" in window) {
        try {
          const root = await window.showDirectoryPicker();
          const folderHandle = await root.getDirectoryHandle(baseName, { create: true });
          await writeFileToDir(folderHandle, baseName + ".pdf", pdfBlob);
          await writeFileToDir(folderHandle, baseName + ".json", jsonBlob);
          downloadStatus.textContent = "Cartella salvata.";
          downloadedFiles = true;
          if (downloadedFiles) setTimeout(() => window.close(), 300);
          return;
        } catch (err) {
          if (err && err.name === "AbortError") {
            downloadStatus.textContent = "Salvataggio annullato.";
            return;
          }
        }
      }
      downloadFilesFallback(baseName, pdfBlob, jsonBlob);
    }

    let fullscreenWarned = false;
    document.addEventListener('fullscreenchange', () => {
      const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      if (!isFs) {
        setTimeout(requestFull, 0);
        if (!fullscreenWarned) {
          fullscreenWarned = true;
          alert("Non rimuovere la modalit? Fullscreen, alla prossima consegnerai il compito.");
        } else {
          finishQuiz();
        }
      }
    });

    window.addEventListener('load', () => {
      requestFull();
    });
  </script>
</body>
</html>