<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Quiz | 16 PUCCI DAVIDE</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: auto; padding: 20px; }
    .hidden { display: none !important; }
    .question { font-weight: bold; margin-top: 20px; }
    .option { display: block; margin: 6px 0; }
    .indicators button { width: 30px; margin: 2px; }
    .green { background: palegreen; }
    .red { background: lightcoral; }
    .noselect, .noselect *:not(input):not(textarea):not(select) { user-select: none; }
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: flex; align-items: center; justify-content: center; z-index: 999; }
    .modal { background: #fff; padding: 20px; border-radius: 8px; max-width: 480px; width: 90%; box-shadow: 0 8px 24px rgba(0,0,0,0.2); text-align: center; }
    .modal button { margin: 8px; padding: 10px 16px; }
    .btn-success { background: palegreen; }
    .status { margin-top: 10px; font-weight: bold; }
  </style>
</head>
<body class="noselect">
  <h2 id="pageTitle">Compito di Tecnologie dei processi di produzione</h2>
  <div id="intro">
    <p><strong>Studente:</strong> 16 PUCCI DAVIDE</p>
    <p><strong>Classe:</strong> 4 AGC</p>
    <p><label><input type="checkbox" id="riduzioneTempo" checked disabled> Riduzione o tempo aggiuntivo</label></p>
    <div style="margin:12px 0; padding:12px; border:1px solid #cbd5e1; border-radius:6px; background:#f1f5f9; color:#0f172a;">
      <strong>Regole del test:</strong>
      <ul style="margin:8px 0 0 18px; padding:0;">
        <li>Una volta avviato il test, entrerai in modalit? fullscreen, non uscire MAI dalla modalit? fullscreen o riceverai un ammonimento. Al secondo ammonimento il test si concluder? automaticamente e dovrai consegnere il documento.</li>
        <li>Se aprirai un'altra scheda, aggiorni la pagina o riduci a icona il test, riceverai un ammonimento; al secondo ammonimento il test si concluder? automaticamente e dovrai consegnere il documento.</li>
        <li>Una volta concluso il test, dovrai scaricare due file: un .pdf e un .json. Cercali negli ultimi download e caricali entrambi sul cloud del docente.</li>
        <li>Non serve scaricare il file "Template" a fine test, poich? risulter? vuoto.</li>
        <li>Quando hai finito il test, avverti il docente alzando la mano.</li>
      </ul>
    </div>
    <button onclick="startQuiz()">Inizia quiz</button>
  </div>

  <div id="quiz" class="hidden">
    <div class="question" id="questionText"></div>
    <div id="options"></div>
    <div style="height:12px;"></div>
    <div style="display:flex; gap:10px; margin:12px 0;">
      <button onclick="prev()">&lt;&lt; Precedente</button>
      <button onclick="next()">Successiva &gt;&gt;</button>
    </div>
    <div style="height:12px;"></div>
    <div class="indicators" id="indicators" style="margin-bottom:14px;"></div>
    <div style="display:flex; justify-content:center; gap:12px; margin:16px 0;">
      <button onclick="finishQuiz()" style="padding:12px 18px; font-size:16px;">Completa e chiudi il test</button>
    </div>
  </div>
  <div id="downloadOverlay" class="hidden overlay">
    <div class="modal">
      <p>Scarica i file PDF e JSON e consegnali al docente.</p>
      <div>
        <button id="downloadPdfBtn" onclick="downloadPdf()">Scarica PDF</button>
        <button id="downloadJsonBtn" onclick="downloadJson()">Scarica JSON</button>
      </div>
      <div id="downloadStatus" class="status"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    const allQuestions = [{"qid":"q1","qhash":"17d87mf","question":"Un flash elettronico portatile è formato da una lampada riempita di gas ___ alloggiata in un riflettore:","options":[{"id":"o11","hash":"1ycdc4k","t":"Xenon"},{"id":"o12","hash":"5838d","t":"Neon"},{"id":"o13","hash":"1ywcjii","t":"Argon"},{"id":"o14","hash":"1xiej1n","t":"Elio"}],"correctHash":"e0jz3n"},{"qid":"q2","qhash":"17n7tbe","question":"Il corpo macchina di una fotocamera comprende tipicamente comandi e componenti dedicati a:","options":[{"id":"o21","hash":"1twa8j3","t":"Impostazioni e controllo dello scatto (esposizione, messa a fuoco, ecc.)"},{"id":"o22","hash":"1u69u82","t":"Emissione della luce (come un soft box)"},{"id":"o23","hash":"1ug9fx1","t":"Misura della luce incidente senza sensore"},{"id":"o24","hash":"1sic828","t":"Proiezione di fondali illuminati"}],"correctHash":"1ai7oqh"},{"qid":"q3","qhash":"17x7f0d","question":"Nelle fotocamere reflex, il mirino ottico permette di vedere la scena grazie a:","options":[{"id":"o31","hash":"1v0bssy","t":"Uno specchio che devia la luce verso un pentaprisma/pentaspecchio"},{"id":"o32","hash":"1uqc73z","t":"Un sensore che proietta sempre l’immagine sul display"},{"id":"o33","hash":"1ugclf0","t":"Un flash che illumina l’interno del mirino"},{"id":"o34","hash":"1u6czq1","t":"Un filtro ND integrato nel mirino"}],"correctHash":"1vw5adj"},{"qid":"q4","qhash":"15za75k","question":"Gli illuminatori a LED si caratterizzano per:","options":[{"id":"o41","hash":"zxaum5","t":"Elevata luminosità con potenza molto contenuta"},{"id":"o42","hash":"z3c1j8","t":"Bassa luminosità e potenza elevata"},{"id":"o43","hash":"zdbn87","t":"Solo luce flash senza luce continua"},{"id":"o44","hash":"yjcu5a","t":"Uso esclusivo su banco ottico"}],"correctHash":"u4dxa1"},{"qid":"q5","qhash":"1699suj","question":"Il difetto maggiore delle photoflood,  riguarda soprattutto:","options":[{"id":"o51","hash":"s5p4ow","t":"La bassa resa cromatica"},{"id":"o52","hash":"sznxrt","t":"La notevole temperatura emessa"},{"id":"o53","hash":"spoc2u","t":"La difficoltà di reperibilità"},{"id":"o54","hash":"tjn55r","t":"La luce troppo fredda"}],"correctHash":"1sgt3cu"},{"qid":"q6","qhash":"16j9eji","question":"Una caratteristica comune delle mirrorless è:","options":[{"id":"o61","hash":"1w3s8h7","t":"L’assenza dello specchio e l’uso di mirino elettronico o display"},{"id":"o62","hash":"1wdru66","t":"La necessità di usare sempre un flash anulare"},{"id":"o63","hash":"1wnrfv5","t":"L’impossibilità di cambiare obiettivo"},{"id":"o64","hash":"1wxr1k4","t":"L’uso obbligatorio di pellicole T"}],"correctHash":"dsoxah"},{"qid":"q7","qhash":"16t908h","question":"La modalità di esposizione Manuale (M) è utile perché:","options":[{"id":"o71","hash":"xpavke","t":"Elimina la necessità di esposimetro"},{"id":"o72","hash":"xfb9vf","t":"Mantiene costante l’esposizione scelta dal fotografo"},{"id":"o73","hash":"x5bo6g","t":"Imposta automaticamente tempi e diaframmi"},{"id":"o74","hash":"z38w19","t":"Funziona solo con il flash"}],"correctHash":"1lycpru"},{"qid":"q8","qhash":"14vbsdo","question":"In modalità Manuale (M), un “vantaggio notevole” è che:","options":[{"id":"o81","hash":"1srqp5l","t":"La coppia tempo/diaframma non cambia finché non la cambiamo noi"},{"id":"o82","hash":"1rxrw2o","t":"La fotocamera imposta sempre automaticamente il diaframma"},{"id":"o83","hash":"1s7rhrn","t":"Il flash non può essere usato"},{"id":"o84","hash":"1tlpi8i","t":"Il WB non è più necessario"}],"correctHash":"1xqj6jd"},{"qid":"q9","qhash":"155be2n","question":"Con i tubi fluorescenti si costruiscono pannelli di grande dimensione apprezzati per il Chroma key perché:","options":[{"id":"o91","hash":"1tvs9fg","t":"Riduce la necessità di stativi"},{"id":"o92","hash":"1upr2id","t":"Contrastano le dominanti verdi o blu del fondale"},{"id":"o93","hash":"1ufrgte","t":"Producono sempre luce calda e rossastra"},{"id":"o94","hash":"1t1tgcj","t":"Sono l’unica luce utilizzabile in esterni"}],"correctHash":"10teu5i"},{"qid":"q10","qhash":"1dtc5wl","question":"Il WB personalizzato viene utilizzato quando:","options":[{"id":"o101","hash":"1dlpshe","t":"La luce è standard e costante"},{"id":"o102","hash":"1dbq6sf","t":"La luce è mista o difficile da interpretare automaticamente"},{"id":"o103","hash":"1d1ql3g","t":"Si fotografa solo in esterni"},{"id":"o104","hash":"1crqzeh","t":"Si utilizza esclusivamente il flash"}],"correctHash":"1y0k3lg"},{"qid":"q11","qhash":"1djck7m","question":"Il mirino elettronico (EVF) è tipicamente associato a:","options":[{"id":"o111","hash":"1cho87j","t":"Fotocamere mirrorless"},{"id":"o112","hash":"1crntwi","t":"Fotocamere a banco ottico"},{"id":"o113","hash":"1d1nflh","t":"Fotocamere solo a pellicola"},{"id":"o114","hash":"1b3q7qo","t":"Fotocamere senza alcun display"}],"correctHash":"bx8cxl"},{"qid":"q12","qhash":"1d9cyin","question":"Nelle fotocamere analogiche, il supporto fotosensibile è:","options":[{"id":"o121","hash":"hf8emc","t":"La pellicola"},{"id":"o122","hash":"i977p9","t":"Il sensore CMOS"},{"id":"o123","hash":"hz7m0a","t":"Il sensore CCD"},{"id":"o124","hash":"gl9ljf","t":"Il display LCD"}],"correctHash":"q9z0j1"},{"qid":"q13","qhash":"1czdcto","question":"Secondo il testo, “L” “M” e “S” nella dimensione dell’immagine indicano:","options":[{"id":"o131","hash":"gb6uch","t":"L’uso di tutti i pixel o di un numero ridotto, variando dimensione e peso del file"},{"id":"o132","hash":"fh819k","t":"La modalità di scatto con flash o senza flash"},{"id":"o133","hash":"fr7myj","t":"Il tipo di lampada (LED, quarzo, fluorescenti)"},{"id":"o134","hash":"h55nfe","t":"Il valore del numero guida"}],"correctHash":"zyhbkx"},{"qid":"q14","qhash":"1cpdr4p","question":"Il diaframma serve principalmente a:","options":[{"id":"o141","hash":"gaov8u","t":"Regolare la quantità di luce che entra nell’obiettivo"},{"id":"o142","hash":"g0p9jv","t":"Aumentare la durata del flash"},{"id":"o143","hash":"fqpnuw","t":"Bloccare l’autofocus"},{"id":"o144","hash":"homvpp","t":"Misurare la luce incidente"}],"correctHash":"7j0np9"}];
    const safeName = (str) => String(str || "").trim().replace(/\s+/g, "_").replace(/[^A-Za-z0-9_-]/g, "");
    const hashId = (value) => {
      const str = String(value || "");
      let hash = 2166136261;
      for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash = Math.imul(hash, 16777619);
      }
      return (hash >>> 0).toString(36);
    };
    const hashJoin = (qid, oid) => hashId(qid + "+" + oid);
    const studentLabel = "16 PUCCI DAVIDE";
    const materiaLabel = "Tecnologie dei processi di produzione";
    const classeLabel = "4 AGC";
    const topicLabel = "Fotocamera e illuminazione";
    const generatedDate = new Date().toLocaleDateString("it-IT");
    let current = 0;
    const answers = {};
    const questionText = document.getElementById('questionText');
    const optionsEl = document.getElementById('options');
    const indicators = document.getElementById('indicators');
    const quizEl = document.getElementById('quiz');
    const introEl = document.getElementById('intro');
    const overlay = document.getElementById('downloadOverlay');
    const downloadStatus = document.getElementById('downloadStatus');

    let finishAsked = false;
    let downloadedPdf = false;
    let downloadedJson = false;

    function requestFull() {
      const el = document.documentElement;
      const fn = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
      if (fn) {
        fn.call(el).catch(() => {});
      }
    }

    function renderQuestion() {
      const q = allQuestions[current];
      questionText.textContent = (current + 1) + '. ' + q.question;
      optionsEl.innerHTML = '';
      if (q.open) {
        const ta = document.createElement('textarea');
        ta.rows = 4;
        ta.style.width = '100%';
        ta.value = answers[q.qid] || '';
        ta.addEventListener('input', () => answers[q.qid] = ta.value);
        optionsEl.appendChild(ta);
      } else {
        const letter = (i) => String.fromCharCode(65 + i);
        q.options.forEach((opt, idx) => {
          const lbl = document.createElement('label');
          lbl.className = 'option';
          const inp = document.createElement('input');
          inp.type = 'radio';
          inp.name = 'opt';
          inp.value = opt.id;
          inp.checked = answers[q.qid] === opt.id;
          inp.addEventListener('change', () => answers[q.qid] = opt.id);
          lbl.appendChild(inp);
          lbl.append(' ' + letter(idx) + '. ' + opt.t);
          optionsEl.appendChild(lbl);
        });
      }
      renderIndicators();
    }

    function renderIndicators() {
      indicators.innerHTML = '';
      allQuestions.forEach((q, idx) => {
        const b = document.createElement('button');
        b.textContent = idx + 1;
        b.className = answers[q.qid] ? 'green' : '';
        b.onclick = () => { current = idx; renderQuestion(); };
        indicators.appendChild(b);
      });
    }

    function startQuiz() {
      introEl.classList.add('hidden');
      quizEl.classList.remove('hidden');
      requestFull();
      renderQuestion();
    }
    function next() { if (current < allQuestions.length - 1) { current++; renderQuestion(); } }
    function prev() { if (current > 0) { current--; renderQuestion(); } }

    function finishQuiz() {
      finishAsked = true;
      quizEl.classList.add('hidden');
      overlay.classList.remove('hidden');
    }

    function downloadPdf() {
      const jsPdfFactory = (window.jspdf && window.jspdf.jsPDF) || window.jsPDF || null;
      if (!jsPdfFactory) {
        alert("Libreria jsPDF non caricata. Impossibile generare il PDF.");
        return;
      }
      const doc = new jsPdfFactory();
      const margin = 20; // 2 cm
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();
      const maxWidth = pageWidth - margin * 2;
      const bottomLimit = () => pageHeight - margin;
      const lineH = 6;
      const letter = (i) => String.fromCharCode(65 + i);
      const colors = {
        primary: [18, 91, 190],
        section: [205, 221, 248],
        text: [15, 30, 60],
        muted: [90, 110, 140]
      };
      let y = margin;
      const ensurePage = (extra = 0) => {
        if (y + extra > bottomLimit()) {
          doc.addPage();
          y = margin;
        }
      };
      const writeLines = (text, opts = {}) => {
        const { indent = 0, font = "normal", size = 11, color = [0,0,0] } = opts;
        doc.setFont("helvetica", font);
        doc.setFontSize(size);
        doc.setTextColor(...color);
        const lines = doc.splitTextToSize(text, maxWidth - indent);
        lines.forEach(txt => {
          ensurePage(lineH);
          doc.text(txt, margin + indent, y);
          y += lineH;
        });
      };
      // Header sezione dati
      doc.setFillColor(...colors.section);
      doc.rect(margin, y, maxWidth, 36, "F");
      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.text("Test su " + topicLabel, margin + 2, y + 8);
      doc.setFontSize(11);
      doc.text("Studente: " + studentLabel, margin + 2, y + 15);
      doc.text("Materia: " + materiaLabel, margin + 2, y + 21);
      doc.text("Classe: " + classeLabel, margin + 2, y + 27);
      doc.text("Data: " + generatedDate, margin + 2, y + 33);
      y += 44;

      doc.setFontSize(11);
      allQuestions.forEach((q, idx) => {
        const questionText = (idx + 1) + ". " + q.question;
        const optionsLines = q.open ? [] : (q.options || []).map((opt, i) => {
          const text = (typeof opt === "string") ? opt : (opt.t || opt.text || opt.testo || opt.label || "");
          return letter(i) + ". " + text;
        });
        const userIdx = answers[q.qid];
        const userLetter = q.open ? "" : (userIdx != null ? letter((q.options || []).findIndex(o => o.id === userIdx)) : "-");
        const correctIdx = q.open ? null : (q.options || []).findIndex(o => hashJoin(q.qid, o.id) === q.correctHash);
        const correctLetter = q.open ? "" : (Number.isInteger(correctIdx) ? letter(correctIdx) : "-");
        const correctOpt = (!q.open && Number.isInteger(correctIdx)) ? (q.options || [])[correctIdx] : null;
        const correctText = correctOpt ? (correctOpt.t || correctOpt.text || correctOpt.testo || correctOpt.label || "") : "";
        const correctLine = q.open ? "" : (correctText ? (correctLetter + ". " + correctText) : correctLetter);

        let blockHeight = doc.splitTextToSize(questionText, maxWidth).length * lineH;
        blockHeight += optionsLines.length * lineH;
        if (!q.open) blockHeight += lineH * 2; // hai risposto + corretta
        if (q.open) blockHeight += doc.splitTextToSize("Risposta: " + (answers[q.qid] || ""), maxWidth).length * lineH;
        blockHeight += lineH * 2;
        ensurePage(blockHeight);

        writeLines(questionText, { font: "bold" });
        if (q.open) {
          const ans = answers[q.qid] || '';
          writeLines("Risposta: " + ans, { indent: 2 });
          writeLines("Domanda aperta - da correggere manualmente.", { indent: 2, color: [90,90,90] });
        } else {
          optionsLines.forEach(line => writeLines(line, { indent: 2 }));
          writeLines("Hai risposto: " + userLetter, { indent: 2 });
          const isCorrect = userIdx != null && Number.isInteger(correctIdx) && (q.options || [])[correctIdx]?.id === userIdx;
          writeLines("Risposta corretta: " + correctLine, { indent: 2, color: isCorrect ? [0,128,0] : [200,0,0] });
        }
        ensurePage(8);
        doc.setDrawColor(...colors.section);
        doc.line(margin, y, margin + maxWidth, y);
        y += 6;
      });

      const closedQuestions = allQuestions.filter(q => !q.open);
      const totalClosed = closedQuestions.length;
      const correctClosed = closedQuestions.reduce((acc, q) => {
        const correctIdx = (q.options || []).findIndex(o => hashJoin(q.qid, o.id) === q.correctHash);
        return acc + ((answers[q.qid] != null && Number.isInteger(correctIdx) && (q.options || [])[correctIdx]?.id === answers[q.qid]) ? 1 : 0);
      }, 0);
      ensurePage(14);
      doc.setFillColor(...colors.section);
      doc.rect(margin, y, maxWidth, 16, "F");
      doc.setFont("helvetica", "bold");
      doc.setFontSize(11);
      doc.text("Totale risposte corrette: " + correctClosed + "/" + totalClosed, margin + 2, y + 7);
      if (totalClosed > 0) {
        const voto = (correctClosed / totalClosed * 10).toFixed(1);
        doc.text("Voto: " + voto, margin + 2, y + 13);
      }

      doc.save('quiz_' + safeName(studentLabel) + '_' + safeName(topicLabel) + '.pdf');
      downloadStatus.textContent = 'PDF generato.';
      downloadedPdf = true;
      if (downloadedPdf && downloadedJson) setTimeout(() => window.close(), 300);
    }

    function downloadJson() {
      const letter = (i) => String.fromCharCode(65 + i);
      const payloadDomande = allQuestions.map((q, idx) => {
        if (q.open) {
          return {
            tipo: "aperta",
            domanda: q.question,
            risposta: answers[q.qid] || ""
          };
        }
        const opts = (q.options || []).map((o, i) => ({
          id: o.id,
          testo: o.t,
          lettera: letter(i)
        }));
        const correctHash = q.correctHash;
        const userId = answers[q.qid];
        const correctOpt = opts.find(o => hashJoin(q.qid, o.id) === correctHash);
        const userOpt = opts.find(o => o.id === userId);
        return {
          tipo: "chiusa",
          domanda: q.question,
          opzioni: opts,
          risposta_corretta: correctOpt ? (correctOpt.lettera + ". " + correctOpt.testo) : "",
          risposta_data: userOpt ? (userOpt.lettera + ". " + userOpt.testo) : ""
        };
      });
      const out = {
        studente: studentLabel,
        classe: classeLabel,
        materia: materiaLabel,
        argomento: topicLabel,
        data: generatedDate,
        domande: payloadDomande
      };
      const blob = new Blob([JSON.stringify(out, null, 2)], { type: 'application/json' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'quiz_' + safeName(studentLabel) + '_' + safeName(topicLabel) + '.json';
      link.click();
      URL.revokeObjectURL(link.href);
      downloadStatus.textContent = 'JSON generato.';
      downloadedJson = true;
      if (downloadedPdf && downloadedJson) setTimeout(() => window.close(), 300);
    }

    let fullscreenWarned = false;
    document.addEventListener('fullscreenchange', () => {
      const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      if (!isFs) {
        setTimeout(requestFull, 0);
        if (!fullscreenWarned) {
          fullscreenWarned = true;
          alert("Non rimuovere la modalit? Fullscreen, alla prossima consegnerai il compito.");
        } else {
          finishQuiz();
        }
      }
    });

    window.addEventListener('load', () => {
      requestFull();
    });
  </script>
</body>
</html>